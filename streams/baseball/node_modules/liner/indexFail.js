'use strict';
var fs = require('fs');
var os = require('os');
var stream = require('stream');
var util = require('util');

var hasStreams2 = stream.Readable !== undefined;
// TODO: Should this class inherit from stream.Transform?
var superclass = hasStreams2 ? stream.Readable : stream;

/**
 * @param source a string file path or a stream
 * @param bufferSize optional; used when source is a file path
 */
function Liner(source, bufferSize) {
  superclass.call(this);

  if (typeof source === 'string') {
    this.fromPath(source, bufferSize);
  } else {
    this.fromStream(source);
  }
}
util.inherits(Liner, superclass);

Liner.prototype._processBuffer = function (buffer) {
  var lines, that = this;

  lines = buffer.toString().split(os.EOL);
  console.log('_processBuffer: lines =', lines);
  lines[0] = this.leftover + lines[0];
  this.leftover = lines.pop();
  lines.forEach(function (line) {
    if (hasStreams2) {
      if (line.length === 0) line = os.EOL;
      that.push(line);
    } else {
      that.emit('data', line);
    }
  });

  if (hasStreams2) this.emit('readable');
};

Liner.prototype._read = function (size) {
  // TODO: Does this need to do anything?
  console.log('Liner _read: entered');
};

/**
 * Reads lines from a given file path.
 * @param filePath the file path
 * @param bufferSize the buffer size used to read the file
 *   (optional; defaults to 512)
 */
Liner.prototype.fromPath = function (filePath, bufferSize) {
  bufferSize = bufferSize || 512;
  var rs = fs.createReadStream(filePath, {bufferSize: bufferSize});
  this.fromStream(rs);
};

/**
 * Reads lines from a given ReadStream.
 * @param readStream the ReadStream
 */
Liner.prototype.fromStream = function (readStream) {
  this.sourceStream = readStream;
  this.leftover = '';

  var that = this;

  if (hasStreams2) {
    readStream.on('readable', function () {
      while (true) {
        var buffer = readStream.read();
        if (!buffer) return;
        that._processBuffer(buffer);
      }
    });
  } else {
    readStream.on('data', function (buffer) {
      that._processBuffer(buffer);
    });
  }

  readStream.on('end', function () {
    if (hasStreams2) {
      that.push(this.leftover);
    } else {
      if (this.leftover) that.emit('data', this.leftover);
    }
  });

  // TODO: Probably don't need if TransformStream is used.
  readStream.on('error', function (err) {
    console.log('Liner fromStream: err =', err);
    that.emit('error', err);
  });

  // TODO: Probably don't need if TransformStream is used.
  readStream.on('close', function (err) {
    console.log('Liner fromStream: got close');
    that.emit('end');
  });
};

module.exports = Liner;
